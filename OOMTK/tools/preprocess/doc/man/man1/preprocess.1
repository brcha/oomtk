.TH "preprocess" 1 "8 Mar 2006" "Preprocess" \" -*- nroff -*-
.ad l
.nh
.SH NAME
preprocess \- A preprocessor for C and C++ modules
.SH "Synopsis"
.PP
\fCpreprocess -c\fP \fIfilename_base\fP [ \fC-o\fP \fIoutfile_base\fP | \fC-s\fP] 
.br
\fC           \fP[ \fC-p\fP \fIprepend\fP ] 
.br
\fC           \fP[ \fC-C\fP \fIsource_ext\fP ] [ \fC-H\fP \fIheader_ext\fP ] 
.br
\fC           \fP[ \fC-e\fP \fItag_list\fP ] 
.br
\fC           \fP[ \fC-i\fP ] [ \fC-t\fP ] [ \fC-l\fP | \fC-L\fP ] [ \fC-v\fP ] [ \fC-d\fP ] 
.br
\fC           \fP\fIsources\fP...
.SH "Description"
.PP
Preprocess is a preprocessor for C++ modules. With this tool, you write \fBunit-style single-source-file modules\fP in C++.
.PP
Preprocess essentially does these things (and frees the programmer from doing them): 
.PD 0

.IP "\(bu" 2
Generate header files that contain declarations for public classes and functions. 
.IP "\(bu" 2
Fill in member-function declarations into class declarations. 
.IP "\(bu" 2
Export public inline and template functions in correct order (you need to declare dependencies for inline functions). 
.IP "\(bu" 2
Optionally, function marked '<code>inline</code>' can be put into the implementation file (out of line). This can ease development (as it temporarily decreases dependencies on header files that change frequently) and debugging. 
.PP
.PP
These automatisms lead to source files that are more logically cohesive (no need to put inline and template functions into a separate file, in a special order) and saves typing effort.
.PP
Preprocess works by transforming unit-style single-source-file C++ modules into three output files: public header, private header, and implementation file. C and C++ comments are preserved during the transformation, keeping the resulting files readable and making it possible to run another preprocessor on Preprocess' output.
.SH "Basic operation"
.PP
.PP
Modules contain two sections. The '<code>INTERFACE:</code>' section contains the public interface to the module; the '<code>IMPLEMENTATION:</code>' section contains everything else. The preprocessor puts interface declarations into a public header file and tries to hide everything else.
.PP
Class definitions deliberately lack declarations for member functions: Preprocess will add them automatically. Member-function definitions (in the implementation section) labelled \fCPUBLIC\fP, \fCPROTECTED\fP and \fCPRIVATE\fP are put into the corresponding section of the class. This feature saves typing effort and reduces duplication.
.PP
From this input file (foo.cpp), Preprocess extracts three C++ source files that can then be processed using the standard C++ compiler toolchain:
.PP
.PP
\fC
.PP
.nf

C++ module -- Preprocess input file
INTERFACE:
.fi
.PP
\fP
.PP
\fC
.PP
.nf
#include 'bar.h'
.fi
.PP
\fP
.PP
\fC
.PP
.nf
struct Baz;
.fi
.PP
\fP
.PP
\fC
.PP
.nf
class Foo : public Bar
{
  Baz* d_baz;
};
.fi
.PP
\fP
.PP
\fC
.PP
.nf
IMPLEMENTATION:
.fi
.PP
\fP
.PP
\fC
.PP
.nf
struct Baz
{
  int data;
};
.fi
.PP
\fP
.PP
\fC
.PP
.nf
PUBLIC
int Foo::get_info() 
{
  return d_baz->data;
}
.fi
.PP
\fP
.PP
.PP
First, Preprocess generates a \fBpublic header file\fP (foo.h). This header file contains all declarations from the interface section, with class definitions properly expanded to contain member-function declarations.
.PP
It also contains declarations of non-'\fCstatic\fP' free functions found in the implementation section, as well as definitions for functions declared '<code>inline</code>'. Additionally, it contains all '<code>\\#include</code>' directives and function and class declarations and definitions the inline functions need; these dependencies need to be declared in the input file. (These features are not shown in the example.)
.PP
If desired, preprocess can also be instructed to hide all inline functions (and to generate them out-of-line instead), resulting in a public header file that better insulates clients from implementation details.
.PP
.PP
\fC
.PP
.nf

Preprocess-generated public header file
#ifndef foo_h
#define foo_h
.fi
.PP
\fP
.PP
\fC
.PP
.nf
#include 'bar.h'
.fi
.PP
\fP
.PP
\fC
.PP
.nf
struct Baz;
.fi
.PP
\fP
.PP
\fC
.PP
.nf
class Foo : public Bar
{
private:
  Baz* d_baz;

public:  
  int get_info();
};
.fi
.PP
\fP
.PP
\fC
.PP
.nf
#endif // foo_h
.fi
.PP
\fP
.PP
.PP
Second, a \fBprivate header file\fP containing all non-public type definitions (foo_i.h). This file can be used by debugging modules that need access to implementation-specific data structures.
.PP
This file also contains all inline member functions belonging to classes declared here. (This feature is not shown in the example.)
.PP
.PP
\fC
.PP
.nf

Preprocess-generated private header file
#ifndef foo_i_h
#define foo_i_h
.fi
.PP
\fP
.PP
\fC
.PP
.nf
struct Baz
{
  int data;
};
.fi
.PP
\fP
.PP
\fC
.PP
.nf
#endif // foo_i_h
.fi
.PP
\fP
.PP
.PP
Third, an \fBimplementation file\fP (foo.cc). This file starts with declarations for all free '<code>static</code>' functions (not shown in the example). Otherwise, it comprises all non-inline function definitions (and static inline functions).
.PP
.PP
\fC
.PP
.nf

Preprocess-generated implementation file
#include 'foo.h'
#include 'foo_i.h'
.fi
.PP
\fP
.PP
\fC
.PP
.nf
void Foo::get_info() 
{
  return d_baz->info();
}
.fi
.PP
\fP
.PP
.SH "Options reference"
.PP
Output files have names of the following form: 
.PD 0

.IP "\(bu" 2
Implementation file: [\fIprepend\fP]\fIoutfile_base\fP[\fC-\fP\fIsuffix\fP]\fC.\fP\fIsource_ext\fP 
.IP "\(bu" 2
Public header file: [\fIprepend\fP]\fIoutfile_base\fP\fC.\fP\fIheader_ext\fP 
.IP "\(bu" 2
Private header file: [\fIprepend\fP]\fIoutfile_base\fP\fC_i.\fP\fIheader_ext\fP 
.PP
.PP
where [\fIprepend\fP] is an optional filename part that can be specified using \fC-p\fP, \fIoutfile_base\fP needs to be specified using \fC-c\fP, \fIsuffix\fP is an optional suffix that can be specified using the \fCIMPLEMENTATION\fP directive, and \fIsource_ext\fP and \fIheader_ext\fP default to '.cc' and '.h' but can be overridden using \fC-C\fP and \fC-H\fP, respectively. 
.IP "\fB\fC-c \fP\fIfilename_base\fP  \fP" 1c
Specifies the basename of generated file names that appear in the output files. This option is mandantory. 
.IP "\fB\fC-o \fP\fIoutfile_base\fP  \fP" 1c
Specifies the basename of output files. It defaults to the value of the \fC-c\fP option. 
.IP "\fB\fC-s\fP \fP" 1c
Generate one implementation file per source file, using the base name of the implementation file as \fIoutfile_base\fP, and not one implementation file per \fIsuffix\fP specified as arguments to \fCIMPLEMENTATION\fP directives in the source files. 
.IP "\fB\fC-p \fP\fIprepend\fP  \fP" 1c
Specifies a prefix for all output file names. This prefix is prepended to \fIfilename_base\fP and can contain directory separators ('<code>/</code>'). 
.IP "\fB\fC-C \fP\fIsource_ext\fP \fP" 1c
Specify the extension of generated implementation files. Defaults to '.cc'. 
.IP "\fB\fC-H \fP\fIheader_ext\fP \fP" 1c
Specify the extension of generated header files. Defaults to '.h'. 
.IP "\fB\fC-e\fP \fItag_list\fP \fP" 1c
Enable conditional compilation using the selectors included in the comma-separated \fItag_list\fP. This option is intended to be used in conjunction with the \fC-s\fP option. See Section \fBConditional compilation\fP CONDITIONAL COMPILATION for details on this option. 
.IP "\fB\fC-t\fP  \fP" 1c
Truncate to size 0 output files for which Preprocess generates no output. This option supresses even \fC#include\fP directives in generated source files that are otherwise empty, resulting in increased compilation speed for these files. 
.IP "\fB\fC-i\fP  \fP" 1c
Generate \fCinline\fP code. If this option is not given, all code (including code marked '<code>inline</code>') is generated out-of-line. 
.IP "\fB\fC-l\fP  \fP" 1c
Avoid generating \fC#line\fP directives in output files. If this option is not given, \fC#line\fP will be generated by default. 
.IP "\fB\fC-L\fP  \fP" 1c
Avoid generating \fC#line\fP directives in header files only. Using this option can speed up builds because the contents of header files change less frequently, as \fC#line\fP directives for (member) function declarations do not have to be updated every time its definition in the source module changes its absolute position. (Of course, this assumes that the time stamp of header files are updated only when the contents of the files change. See Section \fBExample Makefile fragment\fP EXAMPLE MAKEFILE FRAGMENT for a possible way to do this.)  
.IP "\fB\fC-v\fP  \fP" 1c
Be verbose: Print results of \fCpreprocess\fP' parser pass. 
.IP "\fB\fC-d\fP  \fP" 1c
Be verbose: Print a diagnostic when dropping a section in conditional-compilation mode (Option \fC-e\fP). 
.PP
.SH "Language directives"
.PP
Preprocess understands a number of language directive that control its behavior. 
.IP "\fB\fCINTERFACE:\fP \fP" 1c
Starts an interface section. Every declaration from such a section will be copied to the public header file. Class declarations found here (``public class'') will be completed with member-function declarations for member functions found in \fCIMPLEMENTATION\fP sections.  Function definitions are not allowed in this section.
.PP
.IP "\fB\fCIMPLEMENTATION:\fP \fP" 1c
Starts an implementation section. Preprocess tries to hide declarations found in these sections in the internal header file and in the implementation file, as follows: 
.IP "\fBClass declarations (``private classes'') \fP" 1c
(subject to member-function-declaration completion as with those in \fCINTERFACE:\fP sections) end up in the internal header file -- except if a public inline function of a public class depends on the private class, in which case the private class' declaration will be put into the public header file. 
.IP "\fBInclude directives \fP" 1c
underlie the same rules as class declarations. 
.IP "\fBFunction definitions \fP" 1c
are usually held in the implementation file. Public inline functions, private inline functions needed by a public inline function, and functions subject to template instatiation are exported to the public header file. Other inline functions (except static non-member inline functions) are put into the private header file. 
.IP "\fBOther code (e.g., variable definitions) \fP" 1c
is put into the implementation file. 
.PP
.PP
.IP "\fB\fCPUBLIC\fP, \fCPRIVATE\fP, and \fCPROTECTED\fP \fP" 1c
specify member-function visibility.
.PP
.IP "\fB\fCexplicit\fP, \fCstatic\fP, and \fCvirtual\fP \fP" 1c
specify member-function attributes. The attributes will be copied to the automatically-created member-function declarations in class declarations (and removed for the actual function definition, as C++ requires).
.PP
.IP "\fB\fCinline\fP \fP" 1c
specifies inline functions. This attribute will be retained for function definitions (but deleted for automatically-created member-function declarations, as C++ requires). (Inline functions will be exported subject to the rules defined above.)
.PP
.IP "\fB\fCinline NEEDS [\fP\fIdependencies\fP\fC,\fP \fI...\fP \fC]\fP \fP" 1c
like \fCinline\fP, but additionally specifies types, functions, and \fC#include\fP statements that this inline function depends on and that consequently need to be exported as well, in front of this inline function. Preprocess reorders definitions such that all dependencies are defined before the inline function.  Example: <blockquote>
.PP
.nf
\fCinline NEEDS['foo.h', some_func, Some_class,
             Some_other_class::member_func]
int
foo ()
{ }
\fP
.fi
.PP
</blockquote> 
.PP
.SS "Language directives for advanced use"
.IP "\fB\fCIMPLEMENTATION [\fP\fIsuffix\fP\fC]:\fP \fP" 1c
Starts an implementation section with code that will be put into a nonstandard output file. Instead of landing in \fIoutfile_base\fP\fC.cc\fP, the code ends up in \fIoutfile_base\fP\fC-\fP\fIsuffix\fP\fC.cc\fP. This directive is useful if there are several input files that together make up one input module (which are fed to Preprocess at the same time and which share one public and one private header file).
.PP
(This form of the IMPLEMENTATION directive works only if neither the \fC-s\fP (no-suffix) nor the \fC-e\fP (conditional compilation) options are used. See Section \fBConditional compilation\fP CONDITIONAL COMPILATION for information on conditional compilation.)
.PP
.IP "\fB\fCEXTENSION class \fP\fIclassname\fP\fC {\fP ... \fC};\fP \fP" 1c
Extends the definition of class \fIclassname\fP (which usually appears in another input file) with more members. This clause is usually used when a class can be configured with several alternative extensions, for example to provide portability across architectures.
.PP
.IP "\fB\fCIMPLEMENT\fP \fP" 1c
is a member-function attribute that specifies that the member function's declaration \fIshould not\fP be copied to the class declaration. Use this attribute to implement an interface that is already declared in the class declaration.
.PP
.IP "\fB\fCinline NOEXPORT\fP \fP" 1c
specifies inline functions that will not be exported via the public header file even if it is a publibly-visible function. Instead, the function definition will end up in the implementation file.
.PP
.IP "\fB\fCinline ALWAYS_INLINE\fP \fP" 1c
specifies a functions that is generated as an inline function even if the \fC-i\fP option is not used. Use this specifier for functions that absolutely must be inline even in debugging builds.
.PP
.PP
.SS "Conditional compilation"
Conditional compilation is a Preprocess mode that is enabled by using the '<code>-e</code> <var>tag_list</var>' option.
.PP
.IP "\fB\fCINTERFACE [\fP\fItag_expression\fP\fC]:\fP  \fP" 1c
.IP "\fB\fCIMPLEMENTATION [\fP\fItag_expression\fP\fC]:\fP \fP" 1c
A \fItag_expression\fP is a logical expression with negation (!), conjunction (-), disjunction (,), and one level of parentheses ({ and }), using selector tags as its atoms. The \fCINTERFACE\fP or \fCIMPLEMENTATION\fP section is included in the output only if it is true using the selectors specified in \fItag_list\fP.  
.PP
.PP
Examples:
.PP
.PP
.nf
\fCINTERFACE [a,b]:\fP
This section is used whenever a or b is contained in the \fItag_list\fP
.fi
.PP
.PP
.PP
.nf
\fCINTERFACE [a-b]: \fP
This section is used whenever a and b are contained in the \fItag_list\fP
.fi
.PP
.PP
.PP
.nf
\fCINTERFACE [a,b-c]:\fP
This section is used whenever a, or b and c are 
contained in the \fItag_list\fP
.fi
.PP
.PP
.PP
.nf
\fCINTERFACE [!a]:\fP
This section is used whenever a is not contained in the \fItag_list\fP
.fi
.PP
.PP
.PP
.nf
\fCINTERFACE [{a,b}-c]:\fP
This section is used whenever a and c, or b and c are 
contained in the \fItag_list\fP
.fi
.PP
.PP
.PP
.nf
\fCINTERFACE [!a,b-c]:\fP
This section is used whenever a is not contained in the \fItag_list\fP,
or b and c are contained in the \fItag_list\fP
.fi
.PP
.SH "Usage hints"
.PP
When you use Preprocess, there are a few things you need to keep in mind. 
.PD 0

.IP "\(bu" 2
Preprocess currently does not support namespaces and nested classes. It is possible to use namespaces and nested classes defined elsewhere (for example, in a library header file), but you cannot define new namespaces and nested classes.  
.IP "\(bu" 2
Preprocess copies function declarations for publicly visible functions to the public header file. If you use user-defined types in function signatures, you need to '<code>\\#include</code>' the corresponding header files (or add forward declarations) in the '<code>INTERFACE:</code>' section of your module. Private inline functions (which might end up in the public header file) need to specify their include dependencies in a '<code>NEEDS[]</code>' clause.  Also, if you use names declared in an (externally-defined) namespace (such as namespace '<code>std</code>'), you must specify the fully-qualified name (including the namespace) in the function signature (unless you use a '\fCusing namespace\fP' directive in the '\fCINTERFACE:\fP' section, which is not recommended).  
.IP "\(bu" 2
Don't forget to specify inline functions required by other inline functions in the latter's '<code>NEEDS</code>' clause. Otherwise, Preprocess cannot guarantee the correct inline-function order in the output, and you may get compiler warnings like ``inline function is used but not defined.'' This problem is reinforced when using private inline functions, because Preprocess moves them out of the public header file (into the private header file) unless a public function's '<code>NEEDS</code>' clause requires them. 
.PP
.SH "Example Makefile fragment"
.PP
.PP
This is an example fragment from a Makefile (for GNU Make) that generates \fC*.cc\fP, \fC*.h\fP, and \fC*_i.h\fP files on the fly. It only updates the generated files if they actually change; that is, if you change something in the implementation section that does not influence the header files, they will not be updated, avoiding recompilation of files that depend on them.
.PP
This Makefile fragment needs GNU Make and the move-if-change script that only updates a target if it is different from the source.
.PP
This example assumes that you do not use the \fCIMPLEMENTATION[\fP\fIsuffix\fP\fC]\fP directive. If you do plan using this directive, a more elaborate mechanism is needed, such as the one used in the Makefiles for the \fCFiasco microkernel\fP.
.PP
 
.PP
.nf
\fCPREPROCESS = preprocess\fP
.fi
.PP
.PP
.PP
.nf
\fC.PRECIOUS: stamp-%.ready
stamp-%.ready: %.cpp
	$(PREPROCESS) -i -o new_$* -c $* $<
	./move-if-change new_$*.h $*.h 
	./move-if-change new_$*_i.h $*_i.h 
	./move-if-change new_$*.cc $*.cc 
	touch $@\fP
.fi
.PP
.PP
.PP
.nf
\fC%.cc: stamp-%.ready
        @[ -e $@ ] || { rm -f $<; $(MAKE) $<; }\fP
.fi
.PP
.PP
.PP
.nf
\fC%.h: stamp-%.ready
        @[ -e $@ ] || { rm -f $<; $(MAKE) $<; }\fP
.fi
.PP
.PP
.PP
.nf
\fC%_i.h: stamp-%.ready
        @[ -e $@ ] || { rm -f $<; $(MAKE) $<; }\fP
.fi
.PP
.PP
.SH "Limitations and ideas for future extensions"
.PP
.SS "Bugs"
.PP
.PD 0
.IP "\(bu" 2
Namespaces and nested classes currently are unsupported. 
.IP "\(bu" 2
The \fC#line\fP directives Preprocess generates sometimes are offset plus/minus one or two lines to the real code. 
.IP "\(bu" 2
Preprocess doesn't really understand preprocessor constructs besides \fC#include\fP and \fC#if 0\fP; it just copies all other direcitives into the output as it finds them. That makes it easy for you to shoot yourself into the foot. 
.PP
.PP
.SS "Ideas for future extensions"
.PP
.PD 0
.IP "\(bu" 2
Generate HTML documentation for modules/classes. 
.IP "\(bu" 2
Auto-generated getters and setters for attributes 
.IP "\(bu" 2
Auto-generate insulation (wrappers, protocol classes, procedural interface) for any given class. 
.IP "\(bu" 2
Transform input \fC.cpp\fP files into new \fC.cpp\fP files, refactoring or renaming code on the fly. 
.IP "\(bu" 2
Aspect-oriented programming: Weave in extensions (``aspects'') to member functions. Aspects can be synchronization or debugging checks, for example. 
.IP "\(bu" 2
Support for class invariants (design by contract) 
.IP "\(bu" 2
Enforce a set of naming conventions. 
.PP
.SH "Download"
.PP
Preprocess is free software licensed under the GNU General Public License. Its implementation language is Perl, so you need a Perl5 interpreter to run it.
.PP
You can download Preprocess as CVS module '<code>preprocess</code>' from the DROPS project's remote-CVS server. Please refer to the download instructions on DROPS' website.
.SH "Mailing list"
.PP
There is a mailing list to which CVS-commit messages for changes made to preprocess are posted. Please ask me if you would like to be put on this list (see Section \fBAuthor\fP AUTHOR ).
.PP
New releases are periodically announced on <a href=http://freshmeat.net/projects/preprocess/''>the Freshmeat website. If you are a registered Freshmeat user, you can subscribe to these release announcements at http://freshmeat.net/subscribe/36508/.
.SH "Author"
.PP
Michael Hohmuth <hohmuth@inf.tu-dresden.de>
.SH "See also"
.PP
\fC\fCmove-if-change\fP\fP(1) shell script : http://os.inf.tu-dresden.de/~hohmuth/prj/preprocess/move-if-change
.PP
Preprocess project web page : http://os.inf.tu-dresden.de/~hohmuth/prj/preprocess/
.PP
Preprocess was originally written for the Fiasco microkernel : http://os.inf.tu-dresden.de/fiasco/
