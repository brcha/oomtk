/*
 *  Copyright (C) 2007 by Filip Brčić <brcha@users.sourceforge.net>
 *
 *  This file is part of OOMTK (http://launchpad.net/oomtk)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/** \file IDT.cc
 * \brief Description
 */
#include "IDT.h"

#include "Selectors.h"

#include <types.h>

#include <stdio.h>
#include <ansi.h>

#include <PortIO.h>

IDT * IDT::instance()
{
  static IDT instance = IDT();

  return &instance;
};

// Make the interrupt descriptor table
// TODO: NUM_IRQ should be defined elsewhere, probably
#define NUM_IRQ 256
PAGE_ALIGN static uint64_t RealIDT[NUM_IRQ];
PAGE_ALIGN static uint64_t RealIDTD;

IDT::IDT()
{
  IdtTable = reinterpret_cast<GateDescriptor_t*>(&RealIDT);
  IdtDescriptor = reinterpret_cast<uint32_t*>(&RealIDTD);
}

// This is generated by python from IdtDeclaration.py:
//// BEGIN INSERTED CODE ////
#include "__generatedIdtDeclarationCode__.h"
//// END INSERTED CODE ////

// This function does the true work
void IDT::setup()
{
  printf("Loading IDT ... ");
  // initialize interrupt controller (?)

  // Initialize the hardware trap entries
  // This is generated by python from IdtInitialization.py:
  //// BEGIN INSERTED CODE ////
  # include "__generatedIdtInitializationCode__.cc"
  //// END INSERTED CODE ////
  
  // Set breakpoint to present
  IdtTable[3].bits.present = 1;

  // Set all interrupt handlers to point to some stub (or do that in constructor)
  // And of course those that do point somethere to wherever they point to...

  // Try to setup the descriptor...
  uint32_t widt = reinterpret_cast<uint32_t>(&IdtTable);
  IdtDescriptor[0] = (NUM_IRQ*8) | ((widt & 0xffff) << 16);
  IdtDescriptor[1] = widt >> 16;


  PortIO::out8(0x20, 0x11);         /* ctrlr1 init - edge triggered */
  PortIO::out8(0x21, 0x20);         /* interrupts from 0x20 to 0x27 */
  PortIO::out8(0x21, 0x4);          /* cascade on IRQ2 */
  PortIO::out8(0x21, 0x1);          /* 8086 mode */
  PortIO::out8(0x21, 0xff);         /* disable interrupts on pic1 */

  PortIO::out8(0xa0, 0x11);         /* ctrlr2 init - edge triggered */
  PortIO::out8(0xa1, 0x28);         /* interrupts from 0x28 to 0x2f */
  PortIO::out8(0xa1, 0x2);          /* cascade on IRQ2 */
  PortIO::out8(0xa1, 0x1);          /* 8086 mode */
  PortIO::out8(0xa1, 0xff);         /* disable interrupts on pic1 */

  PortIO::out8(0x20,0x20);          /* reset pic1 */
  PortIO::out8(0xa0,0x20);          /* reset pic2 */

  GNU_ASM(
	  "   lidt  %[idtd]\n" // load IDTD
          : /* no output */
	  : [idtd] "m" (RealIDTD)
	  : "memory"
	  );
  printf(ANSI_FG_GREEN "[ok]\n" ANSI_NORMAL);
}

void IDT::SetHardwareVector(int entry, void (*handlerPtr)(void), bool user)
{
  uint32_t intHandlerPtr = reinterpret_cast<uint32_t>(handlerPtr);

  IdtTable[entry].bits.offset_lo  = (uint16_t) intHandlerPtr;
  IdtTable[entry].bits.selector   = sel_KernelCS;
  IdtTable[entry].bits.zero       = 0;
  IdtTable[entry].bits.type       = 0xeu;
  IdtTable[entry].bits.system     = 0;
  /* Use RPL==1 for non-user so kernel threads can call them. */
  IdtTable[entry].bits.dpl        = user ? 3 : 1;
  IdtTable[entry].bits.present    = 1;
  IdtTable[entry].bits.offset_hi  = (uint16_t) (intHandlerPtr >> 16);
}


